<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friends | Sudarsh Kunnavakkam</title>
    <meta name="description" content="Friends and interesting people on the internet.">
    <meta name="author" content="Sudarsh Kunnavakkam">
    <meta name="keywords" content="machine learning, AI safety, language models, nanophotonics, Caltech, research">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Friends | Sudarsh Kunnavakkam">
    <meta property="og:description" content="Friends and interesting people on the internet.">
    <meta name="twitter:card" content="summary">

    <link rel="canonical" href="https:&#x2F;&#x2F;sudarsh.com/friends">
    <script data-goatcounter="https://skunnavakkam.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Space+Mono&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            line-height: 1.6;
            letter-spacing: 0.5px;
            min-height: 100vh;
            background: #fafaf6;
            overflow-x: hidden;
        }

        canvas#scene {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .content-wrapper {
            position: relative;
            z-index: 1;
            max-width: 540px;
            margin: 0 auto;
            padding: 200px 30px 120px;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Space Mono', monospace;
            margin-bottom: 6px;
        }

        .title {
            margin-top: 0;
            font-size: 2.5em;
            color: #2a2a20;
        }

        .nav-links {
            display: flex;
            gap: 15px;
            margin-bottom: 12px;
        }

        a {
            color: #e1b60e;
            text-decoration: underline;
            font-family: 'Space Mono', monospace;
        }

        p {
            color: #6a6a58;
            margin-bottom: 30px;
        }

        ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 0;
        }

        li {
            position: relative;
            padding: 14px 20px;
        }

        li a {
            text-decoration: none;
            font-size: 1.05em;
            color: #4a6a3a;
            transition: color 0.4s;
            position: relative;
        }

        li a:hover {
            color: #e1b60e;
        }

        li {
            overflow: visible;
        }

        li .sakura {
            display: inline-block;
            width: 14px;
            height: 14px;
            margin-right: 8px;
            vertical-align: middle;
            position: relative;
            flex-shrink: 0;
        }

        li .sakura .petal {
            position: absolute;
            width: 6px;
            height: 8px;
            background: #e8b4c0;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            top: 50%;
            left: 50%;
            transform-origin: 50% 100%;
            opacity: 0.8;
            transition: transform 0.4s, opacity 0.3s;
        }

        li .sakura .petal:nth-child(1) { transform: translate(-50%, -100%) rotate(0deg); }
        li .sakura .petal:nth-child(2) { transform: translate(-50%, -100%) rotate(72deg); }
        li .sakura .petal:nth-child(3) { transform: translate(-50%, -100%) rotate(144deg); }
        li .sakura .petal:nth-child(4) { transform: translate(-50%, -100%) rotate(216deg); }
        li .sakura .petal:nth-child(5) { transform: translate(-50%, -100%) rotate(288deg); }

        li .sakura .center {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #f0d080;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        li:hover .sakura .petal {
            opacity: 1;
        }
        li:hover .sakura .petal:nth-child(1) { transform: translate(-50%, -100%) rotate(0deg) scale(1.3); }
        li:hover .sakura .petal:nth-child(2) { transform: translate(-50%, -100%) rotate(72deg) scale(1.3); }
        li:hover .sakura .petal:nth-child(3) { transform: translate(-50%, -100%) rotate(144deg) scale(1.3); }
        li:hover .sakura .petal:nth-child(4) { transform: translate(-50%, -100%) rotate(216deg) scale(1.3); }
        li:hover .sakura .petal:nth-child(5) { transform: translate(-50%, -100%) rotate(288deg) scale(1.3); }

        @keyframes petal-drift {
            0% { opacity: 0.8; transform: translate(0, 0) rotate(0deg) scale(1); }
            100% { opacity: 0; transform: translate(var(--dx), var(--dy)) rotate(var(--rot)) scale(0.3); }
        }

        .petal-particle {
            position: absolute;
            width: 4px;
            height: 5px;
            background: #e8b4c0;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            pointer-events: none;
            z-index: 2;
            animation: petal-drift 1.2s ease-out forwards;
        }
    </style>
</head>

<body>
    <canvas id="scene"></canvas>
    <div class="content-wrapper">
        <h1 class="title">Friends</h1>
        <div class="nav-links">
            <a href="/..">< back home</a>
        </div>
        <p>Here are some of the people I’m fortunate to call my friends; this isn’t exhaustive.</p>
<ul>
<li><a href="https://exr0n.com">Albert</a></li>
<li><a href="https://www.jamlian.com/">Jam</a></li>
<li><a href="https://jasonhausenloy.com/">Jason</a></li>
<li><a href="https://v4913.substack.com/">Vivian</a></li>
<li><a href="https://samfv.systems/">Sam</a></li>
<li><a href="https://lev.la">Lev</a></li>
<li><a href="https://alexrandomkat.neocities.org/">Kat</a></li>
<li><a href="https://jasminexli.com/">Jasmine</a></li>
<li><a href="https://helenatran.com/">Helena</a></li>
<li><a href="https://www.youtube.com/@ivanmarkovavia">Ivan</a></li>
<li><a href="https://quguanni.com/">Jenny</a></li>
<li><a href="https://frankyaoxiao.com/">Frank</a></li>
<li><a href="https://pepsi.pw/">Sammy</a></li>
<li><a href="https://special-fx.carrd.co/">Aaron</a></li>
<li><a href="https://samuelratnam.xyz/">Samuel</a></li>
<li><a href="https://clairebookworm.com">Claire</a></li>
</ul>

    </div>

    <script>
        (() => {
            document.querySelectorAll('li').forEach((li, i) => {
                // inject sakura blossom before the link
                const sakura = document.createElement('span');
                sakura.className = 'sakura';
                sakura.innerHTML = '<span class="petal"></span>'.repeat(5) + '<span class="center"></span>';
                li.insertBefore(sakura, li.firstChild);

                // particle burst on hover
                li.addEventListener('mouseenter', () => {
                    const rect = sakura.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    for (let j = 0; j < 5; j++) {
                        const p = document.createElement('div');
                        p.className = 'petal-particle';
                        const dx = (Math.random() - 0.5) * 40;
                        const dy = -(Math.random() * 25 + 10);
                        const rot = (Math.random() - 0.5) * 180;
                        p.style.cssText = `left:${cx}px;top:${cy}px;--dx:${dx}px;--dy:${dy}px;--rot:${rot}deg;position:fixed;`;
                        document.body.appendChild(p);
                        setTimeout(() => p.remove(), 1300);
                    }
                });
            });

            const canvas = document.getElementById('scene');
            const ctx = canvas.getContext('2d');
            let W, H;
            const dpr = window.devicePixelRatio || 1;

            function resize() {
                W = window.innerWidth;
                H = window.innerHeight;
                canvas.width = W * dpr;
                canvas.height = H * dpr;
                canvas.style.width = W + 'px';
                canvas.style.height = H + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            resize();
            window.addEventListener('resize', resize);

            function rand(a, b) { return a + Math.random() * (b - a); }

            // ============ STROKES: continuous flowing curves ============
            // Each stroke is a pre-generated path of points that gets revealed over time

            function buildStroke(startX, startY, startAngle, length, startWidth, wobbleScale = 1) {
                const points = [];
                const step = 2;
                const count = Math.floor(length / step);
                let x = startX, y = startY;
                // layered waves: big sweeps + medium curves + small wiggles
                const w1 = { freq: rand(0.015, 0.035), amp: rand(0.3, 0.7) * wobbleScale, phase: rand(0, Math.PI * 2) };
                const w2 = { freq: rand(0.05, 0.1),   amp: rand(0.1, 0.3) * wobbleScale, phase: rand(0, Math.PI * 2) };
                const w3 = { freq: rand(0.12, 0.25),   amp: rand(0.03, 0.08) * wobbleScale, phase: rand(0, Math.PI * 2) };

                for (let i = 0; i <= count; i++) {
                    const t = i / count;
                    const width = startWidth * (1 - t * 0.85);
                    points.push({ x, y, width });
                    const curAngle = startAngle
                        + Math.sin(i * w1.freq + w1.phase) * w1.amp
                        + Math.sin(i * w2.freq + w2.phase) * w2.amp
                        + Math.sin(i * w3.freq + w3.phase) * w3.amp;
                    x += Math.cos(curAngle) * step;
                    y += Math.sin(curAngle) * step;
                }

                // flowers scattered along the last 40% of the stroke
                const flowers = [];
                const flowerCount = Math.floor(rand(2, 6));
                for (let i = 0; i < flowerCount; i++) {
                    const t = rand(0.55, 0.95);
                    const idx = Math.floor(t * (points.length - 1));
                    const p = points[idx];
                    const petalCount = Math.floor(rand(4, 7));
                    const baseA = rand(0, Math.PI * 2);
                    const petals = [];
                    for (let layer = 0; layer < 2; layer++) {
                        for (let j = 0; j < petalCount; j++) {
                            const a = baseA + (Math.PI * 2 / petalCount) * j + layer * 0.15;
                            petals.push({
                                a, layer,
                                pr: Math.floor(rand(210, 245)),
                                pg: Math.floor(rand(140, 185)),
                                pb: Math.floor(rand(165, 210)),
                            });
                        }
                    }
                    flowers.push({
                        t, x: p.x + rand(-4, 4), y: p.y + rand(-4, 4),
                        size: rand(4, 9), petals,
                    });
                }

                // leaves along the middle portion
                const leaves = [];
                const leafCount = Math.floor(rand(2, 5));
                for (let i = 0; i < leafCount; i++) {
                    const t = rand(0.25, 0.75);
                    const idx = Math.floor(t * (points.length - 1));
                    const p = points[idx];
                    leaves.push({
                        t, x: p.x, y: p.y,
                        size: rand(5, 10),
                        angle: rand(-Math.PI, Math.PI),
                        swayOff: rand(0, Math.PI * 2),
                        green: Math.floor(rand(130, 185)),
                    });
                }

                return { points, flowers, leaves, totalLen: count };
            }

            function buildTree(baseX, baseY) {
                // shared trunk: a single upward stroke all branches follow
                const trunkAngle = -Math.PI / 2 + rand(-0.03, 0.03);
                const trunkHeight = rand(180, 300);
                const trunkWidth = rand(5, 9);
                const trunkStroke = buildStroke(baseX, baseY, trunkAngle, trunkHeight, trunkWidth, 0.15);

                // the point where branches diverge (60-85% up the trunk)
                const splitFrac = rand(0.6, 0.85);
                const splitIdx = Math.floor(splitFrac * (trunkStroke.points.length - 1));
                const splitPt = trunkStroke.points[splitIdx];

                // trunk gets no flowers/leaves in the shared portion
                trunkStroke.flowers = [];
                trunkStroke.leaves = [];

                const strokes = [{ ...trunkStroke, delay: 0 }];

                // branches diverge from the split point
                const branchCount = Math.floor(rand(4, 8));
                for (let i = 0; i < branchCount; i++) {
                    const spread = rand(-1.2, 1.2);
                    const angle = trunkAngle + spread;
                    const length = rand(120, 280);
                    const width = rand(1.5, 4);
                    const branch = buildStroke(splitPt.x, splitPt.y, angle, length, width);

                    // prepend the shared trunk portion so the branch visually grows from the ground
                    const trunkPrefix = trunkStroke.points.slice(0, splitIdx + 1).map(p => ({ ...p }));
                    branch.points = [...trunkPrefix, ...branch.points];
                    // adjust flower/leaf positions (they reference points in the branch portion)
                    // their t values are relative to the branch, remap to the full stroke
                    const branchStart = trunkPrefix.length / branch.points.length;
                    for (const fl of branch.flowers) fl.t = branchStart + fl.t * (1 - branchStart);
                    for (const lf of branch.leaves) lf.t = branchStart + lf.t * (1 - branchStart);

                    // stagger branch growth so trunk draws first, then branches fan out
                    const delay = splitFrac * 0.6 + rand(0, 0.15);
                    strokes.push({ ...branch, delay });
                }

                return strokes;
            }

            function drawStroke(stroke, growT, now) {
                const localT = Math.max(0, Math.min(1, (growT - stroke.delay) / (1 - stroke.delay)));
                if (localT <= 0) return;

                const pts = stroke.points;
                const drawCount = Math.floor(localT * pts.length);
                if (drawCount < 2) return;

                // draw as a filled tapered shape (polygon) to avoid overlap artifacts
                // build left and right edges offset by width
                const left = [], right = [];
                for (let i = 0; i < drawCount; i++) {
                    const p = pts[i];
                    // direction angle
                    let dx, dy;
                    if (i < drawCount - 1) {
                        dx = pts[i + 1].x - p.x;
                        dy = pts[i + 1].y - p.y;
                    } else {
                        dx = p.x - pts[i - 1].x;
                        dy = p.y - pts[i - 1].y;
                    }
                    const len = Math.sqrt(dx * dx + dy * dy) || 1;
                    // perpendicular normal
                    const nx = -dy / len;
                    const ny = dx / len;
                    const hw = p.width * 0.5;
                    left.push({ x: p.x + nx * hw, y: p.y + ny * hw });
                    right.push({ x: p.x - nx * hw, y: p.y - ny * hw });
                }

                ctx.beginPath();
                ctx.moveTo(left[0].x, left[0].y);
                for (let i = 1; i < left.length; i++) ctx.lineTo(left[i].x, left[i].y);
                for (let i = right.length - 1; i >= 0; i--) ctx.lineTo(right[i].x, right[i].y);
                ctx.closePath();
                ctx.fillStyle = 'rgba(90, 105, 65, 0.55)';
                ctx.fill();

                // leaves
                for (const lf of stroke.leaves) {
                    if (lf.t > localT) continue;
                    const lfAppear = Math.min(1, (localT - lf.t) / 0.15);
                    const sway = Math.sin(now * 0.0012 + lf.swayOff) * 0.1;
                    const s = lf.size * lfAppear;
                    ctx.save();
                    ctx.translate(lf.x, lf.y);
                    ctx.rotate(lf.angle + sway);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.bezierCurveTo(s * 0.35, -s * 0.35, s * 0.75, -s * 0.25, s, 0);
                    ctx.bezierCurveTo(s * 0.75, s * 0.25, s * 0.35, s * 0.35, 0, 0);
                    ctx.fillStyle = `rgba(${lf.green}, ${lf.green + 40}, 80, ${0.3 * lfAppear})`;
                    ctx.fill();
                    ctx.restore();
                }

                // flowers — ruffle when mouse is near
                for (const fl of stroke.flowers) {
                    if (fl.t > localT) continue;
                    const flAppear = Math.min(1, (localT - fl.t) / 0.1);
                    const s = fl.size * flAppear;

                    // mouse proximity → ruffle offset
                    const dx = mouseX - fl.x;
                    const dy = mouseY - fl.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const ruffleRadius = 60;
                    const ruffle = dist < ruffleRadius ? (1 - dist / ruffleRadius) : 0;
                    // push petals away from mouse
                    const pushAngle = Math.atan2(dy, dx);
                    const pushDist = ruffle * 4;
                    const ruffleRot = ruffle * 0.4; // extra rotation scatter

                    for (const p of fl.petals) {
                        const ps = s * (1 - p.layer * 0.2);
                        const scatter = ruffle * Math.sin(p.a * 3 + now * 0.008) * 2;
                        const px = fl.x + Math.cos(p.a) * (ps * 0.55 + pushDist) - Math.cos(pushAngle) * pushDist * 0.3 + scatter;
                        const py = fl.y + Math.sin(p.a) * (ps * 0.55 + pushDist) - Math.sin(pushAngle) * pushDist * 0.3 + scatter;
                        ctx.beginPath();
                        ctx.ellipse(px, py, ps * 0.5, ps * 0.35, p.a + ruffleRot * Math.sin(p.a * 2), 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${p.pr}, ${p.pg}, ${p.pb}, ${(0.35 - p.layer * 0.1) * flAppear})`;
                        ctx.fill();
                    }
                    ctx.beginPath();
                    ctx.arc(fl.x, fl.y, s * 0.15, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(230, 180, 60, ${0.5 * flAppear})`;
                    ctx.fill();
                }
            }

            // ============ BUILD TREES ============
            const groundY = H - 25;
            // place trees flanking the content area
            const contentLeft = (W - 540) / 2;
            const contentRight = (W + 540) / 2;
            const trees = [];
            const minMargin = 120; // don't grow trees if margin is too narrow
            const treeSpacing = 200; // minimum space between trees

            // left side
            if (contentLeft > minMargin) {
                let x = contentLeft - rand(40, 80);
                while (x > 40) {
                    trees.push({
                        strokes: buildTree(x, groundY),
                        birthDelay: trees.length * rand(1500, 3000),
                        growDuration: rand(6000, 10000),
                    });
                    x -= treeSpacing + rand(0, 80);
                }
            }
            // right side
            if (W - contentRight > minMargin) {
                let x = contentRight + rand(40, 80);
                while (x < W - 40) {
                    trees.push({
                        strokes: buildTree(x, groundY),
                        birthDelay: trees.length * rand(1500, 3000),
                        growDuration: rand(6000, 10000),
                    });
                    x += treeSpacing + rand(0, 80);
                }
            }

            // ============ LANTERN ROPE ============
            // A sagging rope strung across the page with lanterns dangling from it
            const ropeY = rand(30, 50);
            const ropeSag = rand(15, 30);
            const ropeSwayOff = rand(0, Math.PI * 2);

            // point on the rope (parabolic sag)
            function ropeAt(frac) {
                const x = frac * W;
                // parabola: deepest at center (frac=0.5)
                const sag = ropeSag * 4 * (frac - 0.5) * (frac - 0.5) - ropeSag;
                return { x, y: ropeY - sag };
            }

            const lanterns = [];
            const lanternCount = Math.max(3, Math.floor(W / 180));
            for (let i = 0; i < lanternCount; i++) {
                const frac = (i + 0.5) / lanternCount + rand(-0.02, 0.02);
                const rp = ropeAt(frac);
                lanterns.push({
                    frac,
                    ropeX: rp.x, ropeY: rp.y,
                    stringLen: rand(25, 45),
                    size: rand(16, 26),
                    swayOff: rand(0, Math.PI * 2),
                    glowPhase: rand(0, Math.PI * 2),
                    angle: 0,
                    angleVel: 0,
                });
            }

            function drawRopeAndLanterns(now, elapsed) {
                // gentle sway on the whole rope
                const ropeSway = Math.sin(now * 0.0004 + ropeSwayOff) * 3;

                // draw rope
                ctx.beginPath();
                for (let i = 0; i <= 80; i++) {
                    const f = i / 80;
                    const rp = ropeAt(f);
                    const x = rp.x;
                    const y = rp.y + ropeSway;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = 'rgba(80, 65, 45, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();

                // draw each lantern
                for (const l of lanterns) {
                    const rp = ropeAt(l.frac);
                    const anchorX = rp.x;
                    const anchorY = rp.y + ropeSway;

                    // pendulum physics
                    // check if mouse is near the lantern body
                    const curX = anchorX + Math.sin(l.angle) * l.stringLen;
                    const curY = anchorY + Math.cos(l.angle) * l.stringLen;
                    const dx = mouseX - curX;
                    const dy = mouseY - curY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const hitRadius = 70;
                    if (dist < hitRadius && Math.abs(smoothVX) > 0.3) {
                        const proximity = (1 - dist / hitRadius);
                        // convert horizontal mouse velocity into angular impulse
                        l.angleVel += smoothVX * 0.0004 * proximity * proximity;
                    }

                    // simple pendulum: -g/L * sin(angle)
                    const gOverL = 0.4 / l.stringLen;
                    l.angleVel -= gOverL * Math.sin(l.angle);
                    l.angleVel *= 0.994; // light air damping — swings 4-5 times
                    l.angle += l.angleVel;
                    // very subtle ambient breeze
                    const ambientSway = Math.sin(now * 0.0005 + l.swayOff) * 0.015;

                    const totalAngle = l.angle + ambientSway;
                    const x = anchorX + Math.sin(totalAngle) * l.stringLen;
                    const y = anchorY + Math.cos(totalAngle) * l.stringLen;
                    const glow = 0.7 + Math.sin(now * 0.002 + l.glowPhase) * 0.3;
                    const s = l.size;

                    // string from rope to lantern (slight curve)
                    ctx.beginPath();
                    ctx.moveTo(anchorX, anchorY);
                    const midX = anchorX + Math.sin(totalAngle) * l.stringLen * 0.5;
                    const midY = anchorY + Math.cos(totalAngle) * l.stringLen * 0.5;
                    ctx.quadraticCurveTo(midX, midY, x, y - s * 0.7);
                    ctx.strokeStyle = 'rgba(80, 65, 45, 0.35)';
                    ctx.lineWidth = 0.6;
                    ctx.stroke();

                    // outer glow
                    const grad = ctx.createRadialGradient(x, y, 0, x, y, s * 4);
                    grad.addColorStop(0, `rgba(255, 210, 80, ${0.18 * glow})`);
                    grad.addColorStop(0.5, `rgba(255, 190, 50, ${0.06 * glow})`);
                    grad.addColorStop(1, 'rgba(255, 190, 50, 0)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(x - s * 4, y - s * 4, s * 8, s * 8);

                    ctx.save();
                    ctx.translate(x, y);
                    // tilt with swing
                    ctx.rotate(totalAngle * 0.5);

                    // lantern body
                    ctx.beginPath();
                    ctx.moveTo(0, -s * 0.7);
                    ctx.bezierCurveTo(s * 0.8, -s * 0.5, s * 0.9, s * 0.3, s * 0.3, s * 0.7);
                    ctx.lineTo(-s * 0.3, s * 0.7);
                    ctx.bezierCurveTo(-s * 0.9, s * 0.3, -s * 0.8, -s * 0.5, 0, -s * 0.7);
                    ctx.fillStyle = `rgba(245, 200, 80, ${0.55 * glow})`;
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(200, 150, 50, 0.3)';
                    ctx.lineWidth = 0.8;
                    ctx.stroke();

                    // inner glow
                    ctx.beginPath();
                    ctx.ellipse(0, 0, s * 0.35, s * 0.45, 0, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 230, 130, ${0.35 * glow})`;
                    ctx.fill();

                    // ribs
                    for (let r = -0.3; r <= 0.3; r += 0.3) {
                        const ry = s * r;
                        const rw = s * 0.6 * (1 - Math.abs(r));
                        ctx.beginPath();
                        ctx.moveTo(-rw, ry);
                        ctx.lineTo(rw, ry);
                        ctx.strokeStyle = 'rgba(180, 140, 50, 0.18)';
                        ctx.lineWidth = 0.4;
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            }

            // ============ MOUSE TRACKING (for flower ruffle + lantern physics) ============
            let mouseX = -1000, mouseY = -1000;
            let smoothVX = 0;
            let lastMouseTime = 0;
            document.addEventListener('mousemove', e => {
                const now = performance.now();
                const dt = now - lastMouseTime;
                if (dt > 0 && dt < 100 && mouseX > -999) {
                    const rawVX = (e.clientX - mouseX) / dt * 16; // normalize to ~per-frame
                    smoothVX = smoothVX * 0.6 + rawVX * 0.4; // smooth out jitter
                }
                lastMouseTime = now;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            document.addEventListener('mouseleave', () => {
                mouseX = -1000;
                mouseY = -1000;
                smoothVX = 0;
            });

            // ============ BUTTERFLIES ============
            const butterflies = [];
            for (let i = 0; i < 3; i++) {
                butterflies.push(makeButterfly(performance.now(), i * 4000));
            }

            function makeButterfly(now, extraDelay) {
                const fromLeft = Math.random() < 0.5;
                return {
                    x: fromLeft ? rand(-30, -10) : rand(W + 10, W + 30),
                    y: rand(H * 0.08, H * 0.5),
                    vx: fromLeft ? rand(0.5, 1.2) : rand(-1.2, -0.5),
                    size: rand(8, 14),
                    wingSpeed: rand(7, 12),
                    wingPhase: rand(0, Math.PI * 2),
                    wobbleFreq: rand(1.5, 3),
                    wobbleOff: rand(0, Math.PI * 2),
                    birth: now + rand(1000, 4000) + extraDelay,
                    life: rand(10000, 20000),
                    color: [[235,160,185],[225,175,200],[240,190,160],[230,195,175]][Math.floor(Math.random() * 4)],
                    trail: [], // dotted trail
                };
            }

            function drawButterfly(bf, now) {
                const elapsed = now - bf.birth;
                if (elapsed < 0) return;
                if (elapsed > bf.life) {
                    Object.assign(bf, makeButterfly(now, 0));
                    return;
                }

                const fadeIn = Math.min(1, elapsed / 800);
                const fadeOut = Math.min(1, (bf.life - elapsed) / 800);
                const alpha = fadeIn * fadeOut;

                // very mild, occasional affinity to cursor
                const curiosity = Math.sin(now * 0.00025 + bf.wobbleOff * 7);
                if (mouseX > -999 && curiosity > 0.6) {
                    const dx = mouseX - bf.x;
                    const dy = mouseY - bf.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 40) {
                        const pull = 0.03 / (1 + dist * 0.01);
                        bf.x += (dx / dist) * pull;
                        bf.y += (dy / dist) * pull;
                    }
                }

                bf.x += bf.vx;
                bf.y += Math.sin(now * 0.001 * bf.wobbleFreq + bf.wobbleOff) * 0.5;

                // record trail points frequently
                if (bf.trail.length === 0 || Math.hypot(bf.x - bf.trail[bf.trail.length - 1].x, bf.y - bf.trail[bf.trail.length - 1].y) > 4) {
                    bf.trail.push({ x: bf.x, y: bf.y, born: now });
                }
                while (bf.trail.length > 80) bf.trail.shift();

                // draw dashed trail
                const [cr, cg, cb] = bf.color;
                const dashLen = 8, gapLen = 6;
                let dashDist = 0;
                let drawing = true;
                for (let i = 1; i < bf.trail.length; i++) {
                    const a = bf.trail[i - 1], b = bf.trail[i];
                    const age = (now - b.born) / 3500;
                    const segAlpha = Math.max(0, (1 - age) * 0.45 * alpha);
                    if (segAlpha <= 0) continue;
                    const segLen = Math.hypot(b.x - a.x, b.y - a.y);
                    dashDist += segLen;
                    if (drawing) {
                        ctx.beginPath();
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);
                        ctx.strokeStyle = `rgba(${cr}, ${cg}, ${cb}, ${segAlpha})`;
                        ctx.lineWidth = 2 * (1 - age * 0.4);
                        ctx.lineCap = 'round';
                        ctx.stroke();
                    }
                    if (dashDist > (drawing ? dashLen : gapLen)) {
                        dashDist = 0;
                        drawing = !drawing;
                    }
                }

                const wing = Math.sin(now * 0.01 * bf.wingSpeed + bf.wingPhase);
                const wingOpen = 0.25 + (wing * 0.5 + 0.5) * 0.75;
                const s = bf.size;

                ctx.save();
                ctx.translate(bf.x, bf.y);
                ctx.rotate(bf.vx > 0 ? 0.05 : -0.05);

                // upper wings
                ctx.beginPath();
                ctx.ellipse(-s * 0.35, -s * 0.1, s * 0.55 * wingOpen, s * 0.4, -0.4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, ${0.55 * alpha})`;
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s * 0.35, -s * 0.1, s * 0.55 * wingOpen, s * 0.4, 0.4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, ${0.55 * alpha})`;
                ctx.fill();

                // lower wings
                ctx.beginPath();
                ctx.ellipse(-s * 0.25, s * 0.15, s * 0.35 * wingOpen, s * 0.25, -0.2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${cr-10}, ${cg-10}, ${cb+10}, ${0.4 * alpha})`;
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(s * 0.25, s * 0.15, s * 0.35 * wingOpen, s * 0.25, 0.2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${cr-10}, ${cg-10}, ${cb+10}, ${0.4 * alpha})`;
                ctx.fill();

                // body
                ctx.beginPath();
                ctx.ellipse(0, 0, s * 0.06, s * 0.3, 0, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(70, 55, 45, ${0.6 * alpha})`;
                ctx.fill();

                // antennae
                ctx.beginPath();
                ctx.moveTo(-s * 0.02, -s * 0.25);
                ctx.quadraticCurveTo(-s * 0.15, -s * 0.5, -s * 0.2, -s * 0.45);
                ctx.moveTo(s * 0.02, -s * 0.25);
                ctx.quadraticCurveTo(s * 0.15, -s * 0.5, s * 0.2, -s * 0.45);
                ctx.strokeStyle = `rgba(70, 55, 45, ${0.4 * alpha})`;
                ctx.lineWidth = 0.5;
                ctx.stroke();

                ctx.restore();
            }

            // ============ GROUND + GRASS ============
            const grassBlades = [];
            for (let x = 0; x < W; x += rand(3, 8)) {
                grassBlades.push({
                    x, h: rand(6, 22), lean: rand(-0.25, 0.25),
                    width: rand(0.4, 1), green: Math.floor(rand(130, 180)),
                    alpha: rand(0.12, 0.3), swaySpeed: rand(0.8, 2), swayOff: rand(0, Math.PI * 2),
                });
            }

            function drawGround(now) {
                const gy = groundY;
                ctx.beginPath();
                ctx.rect(0, gy, W, H - gy);
                ctx.fillStyle = 'rgba(175, 195, 135, 0.12)';
                ctx.fill();

                for (const g of grassBlades) {
                    const sway = Math.sin(now * 0.001 * g.swaySpeed + g.swayOff) * 4;
                    ctx.beginPath();
                    ctx.moveTo(g.x, gy);
                    ctx.quadraticCurveTo(g.x + g.lean * g.h + sway, gy - g.h * 0.6, g.x + g.lean * g.h * 1.5 + sway * 1.5, gy - g.h);
                    ctx.strokeStyle = `rgba(${g.green}, ${g.green + 30}, 70, ${g.alpha})`;
                    ctx.lineWidth = g.width;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
            }

            // ============ POLLEN ============
            const pollen = [];
            for (let i = 0; i < 25; i++) {
                pollen.push({
                    x: rand(0, W), y: rand(0, H), r: rand(0.8, 2),
                    vx: rand(-0.08, 0.08), vy: rand(-0.2, -0.03),
                    opacity: rand(0.12, 0.3), wobble: rand(0.5, 2), wobbleOff: rand(0, Math.PI * 2),
                });
            }

            // ============ MAIN LOOP ============
            const startTime = performance.now();

            function frame(now) {
                ctx.save();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                const elapsed = now - startTime;

                drawGround(now);

                for (const t of trees) {
                    const te = elapsed - t.birthDelay;
                    if (te < 0) continue;
                    const growT = Math.min(1, te / t.growDuration);
                    for (const s of t.strokes) drawStroke(s, growT, now);
                }

                drawRopeAndLanterns(now, elapsed);
                for (const bf of butterflies) drawButterfly(bf, now);

                for (const p of pollen) {
                    p.x += p.vx + Math.sin(now * 0.001 * p.wobble + p.wobbleOff) * 0.03;
                    p.y += p.vy;
                    if (p.y < -5) { p.y = H + 5; p.x = rand(0, W); }
                    if (p.x < -5) p.x = W + 5;
                    if (p.x > W + 5) p.x = -5;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(230, 210, 120, ${p.opacity})`;
                    ctx.fill();
                }

                requestAnimationFrame(frame);
            }

            requestAnimationFrame(frame);
        })();
    </script>
</body>

</html>
