<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ section.title }}</title>
    <meta name="description" content="{{ config.description }}">
    <meta name="author" content="{{ config.extra.author }}">

    <!-- KaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {delimiters:[{left:'$$',right:'$$',display:true},{left:'\\[',right:'\\]',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false}]});"></script>
    <script data-goatcounter="https://skunnavakkam.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Space+Mono&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 30px;
            box-sizing: border-box;
            line-height: 1.6;
            letter-spacing: 0.5px;
        }

        .content-wrapper {
            max-width: max(60%, 600px);
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: 'Space Mono', monospace;
            margin-bottom: 6px;
        }

        .title {
            margin-top: 0px;
            font-size: 2.5em;
        }

        h1 {
            font-size: 2em;
        }

        h2 {
            font-size: 1.7em;
        }

        h3 {
            font-size: 1.6em;
        }

        h4 {
            font-size: 1.1em;
        }

        p {
            margin-bottom: 15px;
        }

        em {
            font-style: italic;
        }

        a {
            color: #e1b60e;
            text-decoration: underline;
            font-family: 'Space Mono', monospace;
        }

        u {
            text-decoration: underline;
        }

        strong {
            font-weight: bold;
        }

        .nav-links {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
        }

        #art-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 550px;
            height: 550px;
            z-index: 10;
            pointer-events: auto;
        }

        #art-container canvas {
            background: transparent !important;
        }

        @media (max-width: 1200px) {
            #art-container {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div class="content-wrapper">
        <h1 class="title">{{ section.title }}</h1>

        <div class="nav-links">
            <a href="/..">
                < back home</a>
        </div>

        {{ section.content | safe }}
    </div>

    <div id="art-container"></div>

    <script>
        (() => {
            const container = document.getElementById('art-container');
            const canvas = document.createElement('canvas');
            container.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            // Config
            const CELL_SIZE = 6;
            const FADE_SPEED = 0.03;
            const SPAWN_INTERVAL = 4000; // ms between pattern spawns
            const STEP_INTERVAL = 120; // ms between generations

            let cols, rows;
            let grid, fade; // grid = alive state, fade = visual opacity (0-1)
            let lastStep = 0;
            let lastSpawn = 0;

            // Classic patterns
            const patterns = {
                glider: [[0,1,0],[0,0,1],[1,1,1]],
                blinker: [[1,1,1]],
                beacon: [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]],
                toad: [[0,1,1,1],[1,1,1,0]],
                lwss: [[0,1,0,0,1],[1,0,0,0,0],[1,0,0,0,1],[1,1,1,1,0]],
                rpentomino: [[0,1,1],[1,1,0],[0,1,0]],
                acorn: [[0,1,0,0,0,0,0],[0,0,0,1,0,0,0],[1,1,0,0,1,1,1]],
            };

            function resize() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                cols = Math.ceil(canvas.width / CELL_SIZE);
                rows = Math.ceil(canvas.height / CELL_SIZE);
                
                // Preserve existing state if possible
                const oldGrid = grid;
                const oldFade = fade;
                const oldCols = oldGrid ? oldGrid.length : 0;
                const oldRows = oldGrid && oldGrid[0] ? oldGrid[0].length : 0;
                
                grid = Array(cols).fill(null).map(() => Array(rows).fill(0));
                fade = Array(cols).fill(null).map(() => Array(rows).fill(0));
                
                // Copy old state
                if (oldGrid) {
                    for (let x = 0; x < Math.min(cols, oldCols); x++) {
                        for (let y = 0; y < Math.min(rows, oldRows); y++) {
                            grid[x][y] = oldGrid[x][y];
                            fade[x][y] = oldFade[x][y];
                        }
                    }
                }
            }

            function countNeighbors(x, y) {
                let sum = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (x + dx + cols) % cols;
                        const ny = (y + dy + rows) % rows;
                        sum += grid[nx][ny];
                    }
                }
                return sum;
            }

            function step() {
                const next = Array(cols).fill(null).map(() => Array(rows).fill(0));
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        const n = countNeighbors(x, y);
                        if (grid[x][y] === 1) {
                            next[x][y] = (n === 2 || n === 3) ? 1 : 0;
                        } else {
                            next[x][y] = (n === 3) ? 1 : 0;
                        }
                    }
                }
                grid = next;
            }

            function placePattern(pattern, cx, cy) {
                const h = pattern.length;
                const w = pattern[0].length;
                for (let py = 0; py < h; py++) {
                    for (let px = 0; px < w; px++) {
                        const x = (cx + px) % cols;
                        const y = (cy + py) % rows;
                        if (pattern[py][px]) {
                            grid[x][y] = 1;
                            fade[x][y] = 1;
                        }
                    }
                }
            }

            function spawnRandomPattern() {
                const names = Object.keys(patterns);
                const name = names[Math.floor(Math.random() * names.length)];
                const pattern = patterns[name];
                
                // Spawn in the visible area, biased toward center-right
                const x = Math.floor(cols * 0.3 + Math.random() * cols * 0.6);
                const y = Math.floor(rows * 0.1 + Math.random() * rows * 0.8);
                
                placePattern(pattern, x, y);
            }

            function updateFade() {
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (grid[x][y] === 1) {
                            fade[x][y] = Math.min(1, fade[x][y] + 0.15);
                        } else {
                            fade[x][y] = Math.max(0, fade[x][y] - FADE_SPEED);
                        }
                    }
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (fade[x][y] > 0.01) {
                            // Calculate distance from top-right corner for fade
                            const nx = x / cols;
                            const ny = y / rows;
                            const cornerDist = Math.sqrt(Math.pow(1 - nx, 2) + Math.pow(ny, 2));
                            const edgeFade = 1 - Math.min(1, Math.max(0, (cornerDist - 0.1) / 0.85));
                            
                            const alpha = fade[x][y] * edgeFade;
                            if (alpha > 0.01) {
                                // Yellow (#e1b60e) with alpha
                                ctx.fillStyle = `rgba(225, 182, 14, ${alpha})`;
                                ctx.fillRect(
                                    x * CELL_SIZE + 1,
                                    y * CELL_SIZE + 1,
                                    CELL_SIZE - 2,
                                    CELL_SIZE - 2
                                );
                            }
                        }
                    }
                }
            }

            function loop(timestamp) {
                // Step the simulation
                if (timestamp - lastStep > STEP_INTERVAL) {
                    step();
                    lastStep = timestamp;
                }

                // Spawn patterns periodically
                if (timestamp - lastSpawn > SPAWN_INTERVAL) {
                    spawnRandomPattern();
                    lastSpawn = timestamp;
                }

                updateFade();
                draw();
                requestAnimationFrame(loop);
            }

            function init() {
                resize();
                
                // Seed with a few patterns
                placePattern(patterns.rpentomino, Math.floor(cols * 0.5), Math.floor(rows * 0.4));
                placePattern(patterns.glider, Math.floor(cols * 0.3), Math.floor(rows * 0.2));
                placePattern(patterns.acorn, Math.floor(cols * 0.6), Math.floor(rows * 0.6));
                
                requestAnimationFrame(loop);
            }

            // Drawing state
            let isDrawing = false;
            let drawMode = 1; // 1 = draw, 0 = erase
            let lastDrawX = -1;
            let lastDrawY = -1;

            function getCellCoords(e) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
                return { x, y };
            }

            function setCell(x, y, value) {
                if (x >= 0 && x < cols && y >= 0 && y < rows) {
                    grid[x][y] = value;
                    if (value === 1) {
                        fade[x][y] = 1;
                    }
                }
            }

            // Bresenham's line algorithm for smooth drawing
            function drawLine(x0, y0, x1, y1, value) {
                const dx = Math.abs(x1 - x0);
                const dy = Math.abs(y1 - y0);
                const sx = x0 < x1 ? 1 : -1;
                const sy = y0 < y1 ? 1 : -1;
                let err = dx - dy;

                while (true) {
                    setCell(x0, y0, value);
                    if (x0 === x1 && y0 === y1) break;
                    const e2 = 2 * err;
                    if (e2 > -dy) { err -= dy; x0 += sx; }
                    if (e2 < dx) { err += dx; y0 += sy; }
                }
            }

            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const { x, y } = getCellCoords(e);
                
                // Shift+click to erase, regular click to draw
                drawMode = e.shiftKey ? 0 : 1;
                
                setCell(x, y, drawMode);
                lastDrawX = x;
                lastDrawY = y;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                
                const { x, y } = getCellCoords(e);
                
                // Draw line from last position to current for smooth strokes
                if (lastDrawX !== -1 && lastDrawY !== -1) {
                    drawLine(lastDrawX, lastDrawY, x, y, drawMode);
                } else {
                    setCell(x, y, drawMode);
                }
                
                lastDrawX = x;
                lastDrawY = y;
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                lastDrawX = -1;
                lastDrawY = -1;
            });

            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
                lastDrawX = -1;
                lastDrawY = -1;
            });

            // Prevent context menu on right-click
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            window.addEventListener('resize', resize);
            init();
        })();
    </script>
</body>

</html>