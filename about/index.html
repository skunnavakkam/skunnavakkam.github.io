<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>About | Sudarsh Kunnavakkam</title>
    <meta name="description" content="About Sudarsh Kunnavakkam - Caltech sophomore working on AI safety, brain modeling, and computational neuroscience.">
    <meta name="author" content="Sudarsh Kunnavakkam">
    <meta name="keywords" content="machine learning, AI safety, language models, nanophotonics, Caltech, research">
    
    <!-- Open Graph -->
    <meta property="og:type" content="profile">
    <meta property="og:title" content="About | Sudarsh Kunnavakkam">
    <meta property="og:description" content="About Sudarsh Kunnavakkam - Caltech sophomore working on AI safety, brain modeling, and computational neuroscience.">
    <meta name="twitter:card" content="summary">
    
    <link rel="canonical" href="https:&#x2F;&#x2F;sudarsh.com/about">

    <!-- KaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {delimiters:[{left:'$$',right:'$$',display:true},{left:'\\[',right:'\\]',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false}]});"></script>
    <script data-goatcounter="https://skunnavakkam.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Space+Mono&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 30px;
            box-sizing: border-box;
            line-height: 1.6;
            letter-spacing: 0.5px;
        }

        .content-wrapper {
            max-width: max(60%, 600px);
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: 'Space Mono', monospace;
            margin-bottom: 6px;
        }

        .title {
            margin-top: 0px;
            font-size: 2.5em;
        }

        h1 {
            font-size: 2em;
        }

        h2 {
            font-size: 1.7em;
        }

        h3 {
            font-size: 1.6em;
        }

        h4 {
            font-size: 1.1em;
        }

        p {
            margin-bottom: 15px;
        }

        em {
            font-style: italic;
        }

        a {
            color: #e1b60e;
            text-decoration: underline;
            font-family: 'Space Mono', monospace;
        }

        u {
            text-decoration: underline;
        }

        strong {
            font-weight: bold;
        }

        .nav-links {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            width: 100%;
        }

        #art-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 550px;
            height: 550px;
            z-index: 10;
            pointer-events: auto;
        }

        #art-container canvas {
            background: transparent !important;
        }

        @media (max-width: 1200px) {
            #art-container {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div class="content-wrapper">
        <h1 class="title">About</h1>

        <div class="nav-links">
            <a href="/..">
                < back home</a>
        </div>

        <p>Hi! I’m Sudarsh, and I’m a Sophomore on leave from a physics degree at Caltech with the hopes of building magical models of brains. You can contact me at <code>kvsudarsh786 at gmail dot com</code>, <code>sudarshk216</code> on signal, or <code>sudarshk_</code> on x.</p>
<p>I think that we’re currently living in one of the most exciting times in history, and I think there’s so much potential for good in the world, and so many wonderful facets to explore. Even though so many things have been discovered in the past, there seems like there’s an explosion of resources in the recent few decades and this feels reflected in the abundance that I feel today.</p>
<h2 id="brains">Brains</h2>
<p>I’m currently working on trying to emulate the brain of a few small model organisms, starting off with the Zebrafish. I’m taking at least a year off from school to work on this. I also worked in a wet lab over the summer doing ultrasound imaging, though I didn’t have many fantastic results from this. </p>
<p>The brain is really remarkable in so many ways to me - the substrate it’s built on is, for lack of a better term, kind of shitty. Neurons are probably not <strong>that</strong> complex, and are <strong>really</strong> slow. Even if all the computation inside a neuron was essential, it’s at the very least limited by diffusion / motor proteins / other biological processes. Computers seem like they should be so much better than the brain is, and yet the brain is about the current frontier of computation. There’s some special sauce here, probably.</p>
<p>For what it’s worth, this could very much just be scale. There may be up to a quintillion neurons in the human brain - it’s probably $\approx 10^3 - 10^4$ ish times larger than the largest neural networks right now, but this only tells half the story for me. I would expect the amount of intellectual “work” to be somewhat proportional to the amount of physics “work” done by the brain, and this is around 30 watts, which is remarkably low! Here are some other brain questions I have:</p>
<ul>
<li>Intelligence scales with the amount of neurons in the prefrontal cortex. Humans have around $14 \pm 2$ billion neurons in the prefrontal cortex, and this is limited by a bunch of evolutionary factors. What if we just increased the number of neurons in the prefrontal cortex, either through gene editing or through adding IPSCs and adding a brain plasticizer?</li>
<li></li>
</ul>
<h2 id="bits">Bits</h2>

    </div>

    <div id="art-container"></div>

    <script>
        (() => {
            const container = document.getElementById('art-container');
            const canvas = document.createElement('canvas');
            container.appendChild(canvas);
            const ctx = canvas.getContext('2d');

            // Config
            const CELL_SIZE = 6;
            const FADE_SPEED = 0.03;
            const SPAWN_INTERVAL = 4000; // ms between pattern spawns
            const STEP_INTERVAL = 120; // ms between generations

            let cols, rows;
            let grid, fade; // grid = alive state, fade = visual opacity (0-1)
            let lastStep = 0;
            let lastSpawn = 0;

            // Classic patterns
            const patterns = {
                glider: [[0,1,0],[0,0,1],[1,1,1]],
                blinker: [[1,1,1]],
                beacon: [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]],
                toad: [[0,1,1,1],[1,1,1,0]],
                lwss: [[0,1,0,0,1],[1,0,0,0,0],[1,0,0,0,1],[1,1,1,1,0]],
                rpentomino: [[0,1,1],[1,1,0],[0,1,0]],
                acorn: [[0,1,0,0,0,0,0],[0,0,0,1,0,0,0],[1,1,0,0,1,1,1]],
            };

            function resize() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                cols = Math.ceil(canvas.width / CELL_SIZE);
                rows = Math.ceil(canvas.height / CELL_SIZE);
                
                // Preserve existing state if possible
                const oldGrid = grid;
                const oldFade = fade;
                const oldCols = oldGrid ? oldGrid.length : 0;
                const oldRows = oldGrid && oldGrid[0] ? oldGrid[0].length : 0;
                
                grid = Array(cols).fill(null).map(() => Array(rows).fill(0));
                fade = Array(cols).fill(null).map(() => Array(rows).fill(0));
                
                // Copy old state
                if (oldGrid) {
                    for (let x = 0; x < Math.min(cols, oldCols); x++) {
                        for (let y = 0; y < Math.min(rows, oldRows); y++) {
                            grid[x][y] = oldGrid[x][y];
                            fade[x][y] = oldFade[x][y];
                        }
                    }
                }
            }

            function countNeighbors(x, y) {
                let sum = 0;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = (x + dx + cols) % cols;
                        const ny = (y + dy + rows) % rows;
                        sum += grid[nx][ny];
                    }
                }
                return sum;
            }

            function step() {
                const next = Array(cols).fill(null).map(() => Array(rows).fill(0));
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        const n = countNeighbors(x, y);
                        if (grid[x][y] === 1) {
                            next[x][y] = (n === 2 || n === 3) ? 1 : 0;
                        } else {
                            next[x][y] = (n === 3) ? 1 : 0;
                        }
                    }
                }
                grid = next;
            }

            function placePattern(pattern, cx, cy) {
                const h = pattern.length;
                const w = pattern[0].length;
                for (let py = 0; py < h; py++) {
                    for (let px = 0; px < w; px++) {
                        const x = (cx + px) % cols;
                        const y = (cy + py) % rows;
                        if (pattern[py][px]) {
                            grid[x][y] = 1;
                            fade[x][y] = 1;
                        }
                    }
                }
            }

            function spawnRandomPattern() {
                const names = Object.keys(patterns);
                const name = names[Math.floor(Math.random() * names.length)];
                const pattern = patterns[name];
                
                // Spawn in the visible area, biased toward center-right
                const x = Math.floor(cols * 0.3 + Math.random() * cols * 0.6);
                const y = Math.floor(rows * 0.1 + Math.random() * rows * 0.8);
                
                placePattern(pattern, x, y);
            }

            function updateFade() {
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (grid[x][y] === 1) {
                            fade[x][y] = Math.min(1, fade[x][y] + 0.15);
                        } else {
                            fade[x][y] = Math.max(0, fade[x][y] - FADE_SPEED);
                        }
                    }
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (fade[x][y] > 0.01) {
                            // Calculate distance from top-right corner for fade
                            const nx = x / cols;
                            const ny = y / rows;
                            const cornerDist = Math.sqrt(Math.pow(1 - nx, 2) + Math.pow(ny, 2));
                            const edgeFade = 1 - Math.min(1, Math.max(0, (cornerDist - 0.1) / 0.85));
                            
                            const alpha = fade[x][y] * edgeFade;
                            if (alpha > 0.01) {
                                // Yellow (#e1b60e) with alpha
                                ctx.fillStyle = `rgba(225, 182, 14, ${alpha})`;
                                ctx.fillRect(
                                    x * CELL_SIZE + 1,
                                    y * CELL_SIZE + 1,
                                    CELL_SIZE - 2,
                                    CELL_SIZE - 2
                                );
                            }
                        }
                    }
                }
            }

            function loop(timestamp) {
                // Step the simulation
                if (timestamp - lastStep > STEP_INTERVAL) {
                    step();
                    lastStep = timestamp;
                }

                // Spawn patterns periodically
                if (timestamp - lastSpawn > SPAWN_INTERVAL) {
                    spawnRandomPattern();
                    lastSpawn = timestamp;
                }

                updateFade();
                draw();
                requestAnimationFrame(loop);
            }

            function init() {
                resize();
                
                // Seed with a few patterns
                placePattern(patterns.rpentomino, Math.floor(cols * 0.5), Math.floor(rows * 0.4));
                placePattern(patterns.glider, Math.floor(cols * 0.3), Math.floor(rows * 0.2));
                placePattern(patterns.acorn, Math.floor(cols * 0.6), Math.floor(rows * 0.6));
                
                requestAnimationFrame(loop);
            }

            // Drawing state
            let isDrawing = false;
            let drawMode = 1; // 1 = draw, 0 = erase
            let lastDrawX = -1;
            let lastDrawY = -1;

            function getCellCoords(e) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);
                return { x, y };
            }

            function setCell(x, y, value) {
                if (x >= 0 && x < cols && y >= 0 && y < rows) {
                    grid[x][y] = value;
                    if (value === 1) {
                        fade[x][y] = 1;
                    }
                }
            }

            // Bresenham's line algorithm for smooth drawing
            function drawLine(x0, y0, x1, y1, value) {
                const dx = Math.abs(x1 - x0);
                const dy = Math.abs(y1 - y0);
                const sx = x0 < x1 ? 1 : -1;
                const sy = y0 < y1 ? 1 : -1;
                let err = dx - dy;

                while (true) {
                    setCell(x0, y0, value);
                    if (x0 === x1 && y0 === y1) break;
                    const e2 = 2 * err;
                    if (e2 > -dy) { err -= dy; x0 += sx; }
                    if (e2 < dx) { err += dx; y0 += sy; }
                }
            }

            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const { x, y } = getCellCoords(e);
                
                // Shift+click to erase, regular click to draw
                drawMode = e.shiftKey ? 0 : 1;
                
                setCell(x, y, drawMode);
                lastDrawX = x;
                lastDrawY = y;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                
                const { x, y } = getCellCoords(e);
                
                // Draw line from last position to current for smooth strokes
                if (lastDrawX !== -1 && lastDrawY !== -1) {
                    drawLine(lastDrawX, lastDrawY, x, y, drawMode);
                } else {
                    setCell(x, y, drawMode);
                }
                
                lastDrawX = x;
                lastDrawY = y;
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                lastDrawX = -1;
                lastDrawY = -1;
            });

            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
                lastDrawX = -1;
                lastDrawY = -1;
            });

            // Prevent context menu on right-click
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            window.addEventListener('resize', resize);
            init();
        })();
    </script>
</body>

</html>